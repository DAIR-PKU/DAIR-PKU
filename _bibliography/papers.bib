---
---

@phdthesis{tuprints13500,
	contributions = {ScalaLoci},
	address = {Darmstadt},
	school = {Technische Universit{\"a}t Darmstadt},
	year = {2020},
	title = {A Programming Language for Distributed Systems},
	author = {Pascal Weisenburger},
	url = {http://tuprints.ulb.tu-darmstadt.de/13500/},
	doi = {10.25534/tuprints-00013500},
	abstract = {Today?s software, including many everyday services, such as online streaming, search engines and social networks, is widely distributed, running on top of a network of interconnected computers. Such distributed applications are traditionally developed as separate modules for each component in the distributed system. These modules react to events, like user input or messages from the network, and in turn produce new events for the other modules. Separation into different modules is problematic because combining modules is notoriously hard and requires extensive and time-consuming integration and manual implementation of communication forces programmers to program complex event-based communication schemes among hosts ? an activity which is often low-level and error-prone. The combination of the two results in obscure distributed data flows scattered among multiple modules, hindering reasoning about the system as a whole. For these reasons, despite most software today is distributed, the design and development of distributed systems remains surprisingly challenging.

	We present the ScalaLoci distributed programming language, our approach for taming the complexity of developing distributed applications via specialized programming language support. ScalaLoci addresses the issues above with a coherent model based on placement types that enables reasoning about distributed data flows otherwise scattered across multiple modules, supporting multiple software architectures via dedicated language features and abstracting over low-level communication details and data conversions.

	ScalaLoci does not force developers to modularize software along network boundaries as is traditionally the case when developing distributed systems. Instead, we propose a module system that supports encapsulating each (cross-host) functionality and defining it over abstract peer types. As a result, we disentangle modularization and distribution and we enable the definition of a distributed system as a composition of ScalaLoci modules, each representing a subsystem.

	Our case studies on distributed algorithms, distributed data structures, as well as on real-world distributed streaming engines show that ScalaLoci simplifies developing distributed systems, reduces error-prone communication code and favors early detection of bugs. As we demonstrate, the ScalaLoci module system allows the definition of reusable patterns of interaction in distributed software and enables separating the modularization and distribution concerns, properly separating functionalities in distributed systems.}
}

@article{10.1145/3428256,
	selected = {true},
	abbr = {OOPSLA},
	contributions = {ConSysT},
	author = {K\"{o}hler, Mirko and Eskandani, Nafise and Weisenburger, Pascal and Margara, Alessandro and Salvaneschi, Guido},
	title = {Rethinking Safe Consistency in Distributed Object-Oriented Programming},
	year = {2020},
	issue_date = {November 2020},
	publisher = {Association for Computing Machinery},
	address = {New York, NY, USA},
	volume = {4},
	number = {OOPSLA},
	url = {https://doi.org/10.1145/3428256},
	doi = {10.1145/3428256},
	abstract = {Large scale distributed systems require to embrace the trade off between consistency and availability, accepting lower levels of consistency to guarantee higher availability. Existing programming languages are, however, agnostic to this compromise, resulting in consistency guarantees that are the same for the whole application and are implicitly adopted from the middleware or hardcoded in configuration files. In this paper, we propose to integrate availability in the design of an object-oriented language, allowing developers to specify different consistency and isolation constraints in the same application at the granularity of single objects. We investigate how availability levels interact with object structure and define a type system that preserves correct program behavior. Our evaluation shows that our solution performs efficiently and improves the design of distributed applications.},
	journal = {Proc. ACM Program. Lang.},
	month = nov,
	articleno = {188},
	numpages = {30},
	keywords = {consistency, replication, Java, type systems}
}

@article{10.1145/3428207,
	abbr = {OOPSLA},
	author = {Zhang, Yizhou and Salvaneschi, Guido and Myers, Andrew C.},
	title = {Handling Bidirectional Control Flow},
	year = {2020},
	issue_date = {November 2020},
	publisher = {Association for Computing Machinery},
	address = {New York, NY, USA},
	volume = {4},
	number = {OOPSLA},
	url = {https://doi.org/10.1145/3428207},
	doi = {10.1145/3428207},
	abstract = {Pressed by the difficulty of writing asynchronous, event-driven code, mainstream languages have recently been building in support for a variety of advanced control-flow features. Meanwhile, experimental language designs have suggested effect handlers as a unifying solution to programmer-defined control effects, subsuming exceptions, generators, and async–await. However, despite these trends, complex control flow—in particular, control flow that exhibits a bidirectional pattern—remains challenging to manage.  We introduce bidirectional algebraic effects, a new programming abstraction that supports bidirectional control transfer in a more natural way. Handlers of bidirectional effects can raise further effects to transfer control back to the site where the initiating effect was raised, and can use themselves to handle their own effects. We present applications of this expressive power, which falls out naturally as we push toward the unification of effectful programming with object-oriented programming. We pin down the mechanism and the unification formally using a core language that makes generalizations to effect operations and effect handlers.  The usual propagation semantics of control effects such as exceptions conflicts with modular reasoning in the presence of effect polymorphism—it breaks parametricity. Bidirectionality exacerbates the problem. Hence, we set out to show the core language, which builds on the existing tunneling semantics for algebraic effects, is not only type-safe (no effects go unhandled), but also abstraction-safe (no effects are accidentally handled). We devise a step-indexed logical-relations model, and construct its parametricity and soundness proofs. These core results are fully mechanized in Coq. While a full-featured compiler is left to future work, experiments show that as a first-class language feature, bidirectional handlers can be implemented efficiently.},
	journal = {Proc. ACM Program. Lang.},
	month = nov,
	articleno = {139},
	numpages = {30},
	keywords = {type systems, iterators, exceptions, Effect handlers, promises, parametricity}
}

@article{10.1145/3397495,
	abbr = {Comp. Surv.},
	contributions = {ScalaLoci},
	author = {Weisenburger, Pascal and Wirth, Johannes and Salvaneschi, Guido},
	title = {A Survey of Multitier Programming},
	year = {2020},
	issue_date = {September 2020},
	publisher = {Association for Computing Machinery},
	address = {New York, NY, USA},
	volume = {53},
	number = {4},
	issn = {0360-0300},
	url = {https://doi.org/10.1145/3397495},
	doi = {10.1145/3397495},
	abstract = {Multitier programming deals with developing the components that pertain to different tiers in the system (e.g., client and server), mixing them in the same compilation unit. In this paradigm, the code for different tiers is then either generated at run time or it results from the compiler splitting the codebase into components that belong to different tiers based on user annotations, static analysis, types, or a combination of these. In the Web context, multitier languages aim at reducing the distinction between client and server code, by translating the code that is to be executed on the clients to JavaScript or by executing JavaScript on the server, too. Ultimately, the goal of the multitier approach is to improve program comprehension, simplify maintenance and enable formal reasoning about the properties of the whole distributed application.A number of multitier research languages have been proposed over the last decade, which support various degrees of multitier programming and explore different design tradeoffs. In this article, we provide an overview of the existing solutions, discuss their positioning in the design space, and outline open research problems.},
	journal = {ACM Comput. Surv.},
	month = sep,
	articleno = {81},
	numpages = {35},
	keywords = {distributed programming, Multitier languages, tierless languages}
}

@inproceedings{10.1145/3427761.3428346,
	abbr = {FTfJP},
	contributions = {ConSysT},
	author = {K\"{o}hler, Mirko and Eskandani, Nafise and Margara, Alessandro and Salvaneschi, Guido},
	title = {ConSysT: Tunable, Safe Consistency Meets Object-Oriented Programming},
	year = {2020},
	isbn = {9781450381864},
	publisher = {Association for Computing Machinery},
	address = {New York, NY, USA},
	url = {https://doi.org/10.1145/3427761.3428346},
	doi = {10.1145/3427761.3428346},
	abstract = {Data replication is essential in scenarios like geo-distributed datacenters, but poses challenges for data consistency. Developers adopt Strong consistency at the cost of performance or embrace Weak consistency and face a higher programming complexity. We argue that languages should associate consistency to data types. We present , a programming language and middleware that provides abstractions to specify consistency types, enabling mixing different consistency levels in the same application. Such mechanism is fully integrated with object-oriented programming and type system guarantees that different levels can only be mixed correctly.},
	booktitle = {Proceedings of the 22nd ACM SIGPLAN International Workshop on Formal Techniques for Java-Like Programs},
	pages = {15–17},
	numpages = {3},
	keywords = {Java, consistency, replication, type systems},
	location = {Virtual, USA},
	series = {FTfJP 2020}
}

@inproceedings{10.1145/3395363.3397367,
	abbr = {ISSTA},
	author = {Helm, Dominik and K\"{u}bler, Florian and K\"{o}lzer, Jan Thomas and Haller, Philipp and Eichberg, Michael and Salvaneschi, Guido and Mezini, Mira},
	title = {A Programming Model for Semi-Implicit Parallelization of Static Analyses},
	year = {2020},
	isbn = {9781450380089},
	publisher = {Association for Computing Machinery},
	address = {New York, NY, USA},
	url = {https://doi.org/10.1145/3395363.3397367},
	doi = {10.1145/3395363.3397367},
	abstract = {Parallelization of static analyses is necessary to scale to real-world programs, but it is a complex and difficult task and, therefore, often only done manually for selected high-profile analyses. In this paper, we propose a programming model for semi-implicit parallelization of static analyses which is inspired by reactive programming. Reusing the domain-expert knowledge on how to parallelize anal- yses encoded in the programming framework, developers do not need to think about parallelization and concurrency issues on their own. The programming model supports stateful computations, only requires monotonic computations over lattices, and is independent of specific analyses. Our evaluation shows the applicability of the programming model to different analyses and the importance of user-selected scheduling strategies. We implemented an IFDS solver that was able to outperform a state-of-the-art, specialized parallel IFDS solver both in absolute performance and scalability.},
	booktitle = {Proceedings of the 29th ACM SIGSOFT International Symposium on Software Testing and Analysis},
	pages = {428–439},
	numpages = {12},
	keywords = {static analysis, parallelization, concurrency},
	location = {Virtual Event, USA},
	series = {ISSTA 2020}
}

@INPROCEEDINGS{9308082,
	abbr = {SuperCompCloud},
	contributions = {ScalaLoci},
	author = {Sokolowski, Daniel and Lehr, Jan-Patrick and Bischof, Christian and Salvaneschi, Guido},
	booktitle = {2020 IEEE/ACM International Workshop on Interoperability of Supercomputing and Cloud Technologies (SuperCompCloud)},
	title = {Leveraging Hybrid Cloud HPC with Multitier Reactive Programming},
	year = {2020},
	volume = {},
	number = {},
	pages = {27-32},
	doi = {10.1109/SuperCompCloud51944.2020.00010}
}

@article{tubiblio120224,
	abbr = {Art Sci. Eng. Program.},
	contributions = {ScalaLoci},
	number = {3},
	journal = {The Art, Science, and Engineering of Programming},
	author = {Pascal Weisenburger and Guido Salvaneschi},
	issn = {2473-7321},
	pages = {17:1--17:29},
	month = {Februar},
	year = {2020},
	title = {Implementing a Language for Distributed Systems: Choices and Experiences with Type Level and Macro Programming in Scala},
	publisher = {AOSA, Inc},
	abstract = {Multitier programming languages reduce the complexity of developing distributed systems by developing the distributed system in a single coherent code base. The compiler or the runtime separate the code for the components of the distributed system, enabling abstraction over low level implementation details such as data representation, serialization and network protocols. Our ScalaLoci language allows developers to declare the different components and their architectural relation at the type level, allowing static reasoning about about distribution and remote communication and guaranteeing static type safety across components. The compiler splits the multitier program into the component-specific code and automatically generates the communication boilerplate. Communication between components can be modeled by declaratively specifying data flows between components using reactive programming.

	In this paper, we report on the implementation of our design and our experience with embedding our language features into Scala as a host language. We show how a combination of Scala?s advanced type level programming and its macro system can be used to enrich the language with new abstractions. We comment on the challenges we encountered and the solutions we developed for our current implementation and outline suggestions for an improved macro system to support the such use cases of embedding of domain-specific abstractions.},
	url = {http://tubiblio.ulb.tu-darmstadt.de/120224/},
	keywords = {emergenCITY\_INF; Engineering; E5}
}
@inproceedings{10.1109/ASE.2019.00082,
	abbr = {ASE},
	author = {K\"{o}hler, Mirko and Salvaneschi, Guido},
	title = {Automated Refactoring to Reactive Programming},
	year = {2019},
	isbn = {9781728125084},
	publisher = {IEEE Press},
	url = {https://doi.org/10.1109/ASE.2019.00082},
	doi = {10.1109/ASE.2019.00082},
	abstract = {Reactive programming languages and libraries, such as ReactiveX, have been shown to significantly improve software design and have seen important industrial adoption over the last years. Asynchronous applications - which are notoriously error-prone to implement and to maintain - greatly benefit from reactive programming because they can be defined in a declarative style, which improves code clarity and extensibility.In this paper, we tackle the problem of refactoring existing software that has been designed with traditional abstractions for asynchronous programming. We propose 2Rx, a refactoring approach to automatically convert asynchronous code to reactive programming. Our evaluation on top-starred GitHub projects shows that 2Rx is effective with common asynchronous constructs and it can provide a refactoring for 91.7% of their occurrences.},
	booktitle = {Proceedings of the 34th IEEE/ACM International Conference on Automated Software Engineering},
	pages = {835–846},
	numpages = {12},
	keywords = {refactoring, reactive programming, asynchronous programming, Java},
	location = {San Diego, California},
	series = {ASE '19}
}

@inproceedings{10.1145/3358503.3361274,
	abbr = {REBLS},
	author = {Bl\"{o}cher, Marcel and Eichholz, Matthias and Weisenburger, Pascal and Eugster, Patrick and Mezini, Mira and Salvaneschi, Guido},
	title = {GRASS: Generic Reactive Application-Specific Scheduling},
	year = {2019},
	isbn = {9781450369862},
	publisher = {Association for Computing Machinery},
	address = {New York, NY, USA},
	url = {https://doi.org/10.1145/3358503.3361274},
	doi = {10.1145/3358503.3361274},
	abstract = {High resource utilization is important to operate compute infrastructures and data centers efficiently. High utilization is achieved by multiplexing several applications over the same physical infrastructure. Yet, with this approach, the different requirements of each application have to be taken into account when scheduling resources. We propose GRASS, a reactive domain-specific abstraction that allows specifying application-tailored resource scheduling policies. We demonstrate how the declarative approach of GRASS enables extension and composition of scheduling policies. Our evaluation shows the performance benefits of considering application-specific information in a composition of scheduling policies that adapt at run time.},
	booktitle = {Proceedings of the 6th ACM SIGPLAN International Workshop on Reactive and Event-Based Languages and Systems},
	pages = {21–30},
	numpages = {10},
	keywords = {Reactive Programming, Data Center Resource Scheduling},
	location = {Athens, Greece},
	series = {REBLS 2019}
}

@article{DBLP:journals/corr/abs-1907-02990,
	abbr = {CoRR},
	author    = {Oliver Bracevac and
	           Guido Salvaneschi and
	           Sebastian Erdweg and
	           Mira Mezini},
	title     = {Type-safe, Polyvariadic Event Correlation},
	journal   = {CoRR},
	volume    = {abs/1907.02990},
	year      = {2019},
	url       = {http://arxiv.org/abs/1907.02990},
	archivePrefix = {arXiv},
	eprint    = {1907.02990},
	timestamp = {Wed, 17 Jul 2019 10:27:36 +0200},
	biburl    = {https://dblp.org/rec/journals/corr/abs-1907-02990.bib},
	bibsource = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{10.1145/3359061.3362779,
	contributions = {ConSysT},
	author = {Eskandani, Nafise and K\"{o}hler, Mirko and Margara, Alessandro and Salvaneschi, Guido},
	title = {Distributed Object-Oriented Programming with Multiple Consistency Levels in ConSysT},
	year = {2019},
	isbn = {9781450369923},
	publisher = {Association for Computing Machinery},
	address = {New York, NY, USA},
	url = {https://doi.org/10.1145/3359061.3362779},
	doi = {10.1145/3359061.3362779},
	abstract = {Data replication is essential in scenarios like geo-distributed datacenters and edge computing. Yet, it poses a challenge for data consistency. Developers either adopt high consistency at the detriment of performance or they embrace low consistency and face a much higher programming complexity. We argue that language abstractions should support associating the level of consistency to data types. We present ConSysT, a programming language and middleware that provides abstractions to specify consistency types, enabling mixing different consistency levels in the same application. Such mechanism is fully integrated with object-oriented programming and type system guarantees that different levels can be mixed only in a correct way.},
	booktitle = {Proceedings Companion of the 2019 ACM SIGPLAN International Conference on Systems, Programming, Languages, and Applications: Software for Humanity},
	pages = {13–14},
	numpages = {2},
	keywords = {distributed systems, Java, replication, type systems, consistency},
	location = {Athens, Greece},
	series = {SPLASH Companion 2019}
}

@article{10.1145/3360593,
	abbr = {OOPSLA},
	author = {Salvaneschi, Guido and K\"{o}hler, Mirko and Sokolowski, Daniel and Haller, Philipp and Erdweg, Sebastian and Mezini, Mira},
	title = {Language-Integrated Privacy-Aware Distributed Queries},
	year = {2019},
	issue_date = {October 2019},
	publisher = {Association for Computing Machinery},
	address = {New York, NY, USA},
	volume = {3},
	number = {OOPSLA},
	url = {https://doi.org/10.1145/3360593},
	doi = {10.1145/3360593},
	abstract = {Distributed query processing is an effective means for processing large amounts of data. To abstract from the technicalities of distributed systems, algorithms for operator placement automatically distribute sequential data queries over the available processing units. However, current algorithms for operator placement focus on performance and ignore privacy concerns that arise when handling sensitive data.  We present a new methodology for privacy-aware operator placement that both prevents leakage of sensitive information and improves performance. Crucially, our approach is based on an information-flow type system for data queries to reason about the sensitivity of query subcomputations. Our solution unfolds in two phases. First, placement space reduction generates deployment candidates based on privacy constraints using a syntax-directed transformation driven by the information-flow type system. Second, constraint solving selects the best placement among the candidates based on a cost model that maximizes performance. We verify that our algorithm preserves the sequential behavior of queries and prevents leakage of sensitive data. We implemented the type system and placement algorithm for a new query language SecQL and demonstrate significant performance improvements in benchmarks.},
	journal = {Proc. ACM Program. Lang.},
	month = oct,
	articleno = {167},
	numpages = {30},
	keywords = {Information-Flow Type System, Scala, Operator Placement, SQL, Data Privacy}
}

@article{10.1145/3360570,
	abbr = {OOPSLA},
	contributions = {REScala},
	author = {Mogk, Ragnar and Drechsler, Joscha and Salvaneschi, Guido and Mezini, Mira},
	title = {A Fault-Tolerant Programming Model for Distributed Interactive Applications},
	year = {2019},
	issue_date = {October 2019},
	publisher = {Association for Computing Machinery},
	address = {New York, NY, USA},
	volume = {3},
	number = {OOPSLA},
	url = {https://doi.org/10.1145/3360570},
	doi = {10.1145/3360570},
	abstract = {Ubiquitous connectivity of web, mobile, and IoT computing platforms has fostered a variety of distributed applications with decentralized state. These applications execute across multiple devices with varying reliability and connectivity. Unfortunately, there is no declarative fault-tolerant programming model for distributed interactive applications with an inherently decentralized system model.  We present a novel approach to automating fault tolerance using high-level programming abstractions tailored to the needs of distributed interactive applications. Specifically, we propose a calculus that enables formal reasoning about applications' dataflow within and across individual devices. Our calculus reinterprets the functional reactive programming model to seamlessly integrate its automated state change propagation with automated crash recovery of device-local dataflow and disconnection-tolerant distribution with guaranteed automated eventual consistency semantics based on conflict-free replicated datatypes. As a result, programmers are relieved of handling intricate details of distributing change propagation and coping with distribution failures in the presence of interactivity. We also provides proofs of our claims, an implementation of our calculus, and an empirical evaluation using a common interactive application.},
	journal = {Proc. ACM Program. Lang.},
	month = oct,
	articleno = {144},
	numpages = {29},
	keywords = {distributed systems, fault tolerance, interactive applications}
}

@inproceedings{10.1145/3328905.3332465,
	abbr = {DEBS},
	contributions = {ScalaLoci},
	author = {Weisenburger, Pascal and Salvaneschi, Guido},
	title = {Developing Distributed Systems with Multitier Programming},
	year = {2019},
	isbn = {9781450367943},
	publisher = {Association for Computing Machinery},
	address = {New York, NY, USA},
	url = {https://doi.org/10.1145/3328905.3332465},
	doi = {10.1145/3328905.3332465},
	abstract = {Developing distributed systems is a complex task that requires to program different peers, often using several languages on different platforms, writing communication code and handling data serialization and conversion.We show how the multitier programming paradigm can alleviate these issues, supporting a development model where all peers in the system can be written in the same language and coexist in the same compilation units, communication code is automatically inserted by the compiler and the language abstracts over data conversion and serialization. We present multitier programming abstractions, discuss their applicability step by step for the development of small applications and discuss larger case studies on distributed stream processing, like Apache Flink and Apache Gearpump.},
	booktitle = {Proceedings of the 13th ACM International Conference on Distributed and Event-Based Systems},
	pages = {203–204},
	numpages = {2},
	keywords = {Scala, Placement Types, Reactive Programming, Multitier Programming, Distributed Programming},
	location = {Darmstadt, Germany},
	series = {DEBS '19}
}

@inproceedings{10.1145/3328433.3328446,
	abbr = {Programming},
	contributions = {J<sub>E</sub>},
	author = {Oak, Aditya and Mezini, Mira and Salvaneschi, Guido},
	title = {Language Support for Multiple Privacy Enhancing Technologies},
	year = {2019},
	isbn = {9781450362573},
	publisher = {Association for Computing Machinery},
	address = {New York, NY, USA},
	url = {https://doi.org/10.1145/3328433.3328446},
	doi = {10.1145/3328433.3328446},
	abstract = {Privacy is one of the critical aspects in the design of computing systems. Various techniques are being used to enforce privacy, such as information flow control, symmetric/asymmetric cryptography, secure computing enclaves, partial homomorphic encryption and differential privacy. These mechanisms should ideally be combined in complex software systems as they offer different properties and performance trade offs. Unfortunately, reasoning about the privacy properties of such combination is still an open research problem.In this paper, we present our vision on a programming language in which we incorporate different privacy preservation techniques in a common programming model.},
	booktitle = {Proceedings of the Conference Companion of the 3rd International Conference on Art, Science, and Engineering of Programming},
	articleno = {12},
	numpages = {2},
	keywords = {programming languages, information flow control},
	location = {Genova, Italy},
	series = {Programming '19}
}

@INPROCEEDINGS{8792001,
	abbr = {FAS*W},
	author = {Casadei, Roberto and Pianini, Danilo and Salvaneschi, Guido and Viroli, Mirko},
	booktitle = {2019 IEEE 4th International Workshops on Foundations and Applications of Self* Systems (FAS*W)},
	title = {On Context-Orientation in Aggregate Programming},
	year = {2019},
	volume = {},
	number = {},
	pages = {92-97},
	doi = {10.1109/FAS-W.2019.00035}
}

@unpublished{lociLulesh,
	abbr = {REBLS},
	contributions = {ScalaLoci},
	author = {Daniel Sokolowski and Philipp Martens and Guido Salvaneschi},
	title  = {{Multitier Reactive Programming in High Performance Computing}},
	note = {6th Workshop on Reactive and Event-based Languages \& Systems},
	url = {https://2019.splashcon.org/details/rebls-2019-papers/2/Multitier-Reactive-Programming-in-High-Performance-Computing},
	year = {2019},
}

@InProceedings{weisenburger_et_al:LIPIcs:2019:10795,
	abbr = {ECOOP},
	contributions = {ScalaLoci},
	author =	{Pascal Weisenburger and Guido Salvaneschi},
	title =	{{Multitier Modules}},
	booktitle =	{33rd European Conference on Object-Oriented Programming (ECOOP 2019)},
	pages =	{3:1--3:29},
	series =	{Leibniz International Proceedings in Informatics (LIPIcs)},
	ISBN =	{978-3-95977-111-5},
	ISSN =	{1868-8969},
	year =	{2019},
	volume =	{134},
	editor =	{Alastair F. Donaldson},
	publisher =	{Schloss Dagstuhl--Leibniz-Zentrum fuer Informatik},
	address =	{Dagstuhl, Germany},
	URL =		{http://drops.dagstuhl.de/opus/volltexte/2019/10795},
	URN =		{urn:nbn:de:0030-drops-107957},
	doi =		{10.4230/LIPIcs.ECOOP.2019.3},
	annote =	{Keywords: Distributed Programming, Multitier Programming, Abstract Peer Types, Placement Types, Module Systems, Scala}
}

@InProceedings{eichholz_et_al:LIPIcs:2019:10804,
	abbr = {ECOOP},
	author =	{Matthias Eichholz and Eric Campbell and Nate Foster and Guido Salvaneschi and Mira Mezini},
	title =	{{How to Avoid Making a Billion-Dollar Mistake: Type-Safe Data Plane Programming with SafeP4}},
	booktitle =	{33rd European Conference on Object-Oriented Programming (ECOOP 2019)},
	pages =	{12:1--12:28},
	series =	{Leibniz International Proceedings in Informatics (LIPIcs)},
	ISBN =	{978-3-95977-111-5},
	ISSN =	{1868-8969},
	year =	{2019},
	volume =	{134},
	editor =	{Alastair F. Donaldson},
	publisher =	{Schloss Dagstuhl--Leibniz-Zentrum fuer Informatik},
	address =	{Dagstuhl, Germany},
	URL =		{http://drops.dagstuhl.de/opus/volltexte/2019/10804},
	URN =		{urn:nbn:de:0030-drops-108041},
	doi =		{10.4230/LIPIcs.ECOOP.2019.12},
	annote =	{Keywords: P4, data plane programming, type systems}
}

@INPROCEEDINGS{9033134,
	abbr = {GHTC},
	author = {Baumgärtner, Lars and Höchst, Jonas and Lampe, Patrick and Mogk, Ragnar and Sterz, Artur and Weisenburger, Pascal and Mezini, Mira and Freisleben, Bernd},
	booktitle = {2019 IEEE Global Humanitarian Technology Conference (GHTC)},
	title = {Smart Street Lights and Mobile Citizen Apps for Resilient Communication in a Digital City},
	year = {2019},
	volume = {},
	number = {},
	pages = {1-8},
	doi = {10.1109/GHTC46095.2019.9033134}
}

@article{10.1145/3276499,
	abbr = {OOPSLA},
	contributions = {ScalaLoci},
	author = {Weisenburger, Pascal and K\"{o}hler, Mirko and Salvaneschi, Guido},
	title = {Distributed System Development with ScalaLoci},
	year = {2018},
	issue_date = {November 2018},
	publisher = {Association for Computing Machinery},
	address = {New York, NY, USA},
	volume = {2},
	number = {OOPSLA},
	url = {https://doi.org/10.1145/3276499},
	doi = {10.1145/3276499},
	abstract = {Distributed applications are traditionally developed as separate modules, often in different languages, which react to events, like user input, and in turn produce new events for the other modules. Separation into components requires time-consuming integration. Manual implementation of communication forces programmers to deal with low-level details. The combination of the two results in obscure distributed data flows scattered among multiple modules, hindering reasoning about the system as a whole.  The ScalaLoci distributed programming language addresses these issues with a coherent model based on placement types that enables reasoning about distributed data flows, supporting multiple software architectures via dedicated language features and abstracting over low-level communication details and data conversions. As we show, ScalaLoci simplifies developing distributed systems, reduces error-prone communication code and favors early detection of bugs.},
	journal = {Proc. ACM Program. Lang.},
	month = oct,
	articleno = {129},
	numpages = {30},
	keywords = {Reactive Programming, Placement Types, Distributed Programming, Scala, Multitier Programming}
}

@article{10.1145/3276477,
	abbr = {OOPSLA},
	contributions = {REScala},
	author = {Drechsler, Joscha and Mogk, Ragnar and Salvaneschi, Guido and Mezini, Mira},
	title = {Thread-Safe Reactive Programming},
	year = {2018},
	issue_date = {November 2018},
	publisher = {Association for Computing Machinery},
	address = {New York, NY, USA},
	volume = {2},
	number = {OOPSLA},
	url = {https://doi.org/10.1145/3276477},
	doi = {10.1145/3276477},
	abstract = {The execution of an application written in a reactive language involves transfer of data and control flow between imperative and reactive abstractions at well-defined points. In a multi-threaded environment, multiple such interactions may execute concurrently, potentially causing data races and event ordering ambiguities. Existing RP languages either disable multi-threading or handle it at the cost of reducing expressiveness or weakening consistency. This paper proposes a model for thread-safe reactive programming (RP) that ensures abort-free strict serializability under concurrency while sacrificing neither expressiveness nor consistency. We also propose an architecture for integrating a corresponding scheduler into the RP language runtime, such that thread-safety is provided "out-of-the-box" to the applications.  We show the feasibility of our proposal by providing and evaluating a ready-to-use implementation integrated into the REScala programming language. The scheduling algorithm is formally proven correct. A thorough empirical evaluation shows that reactive applications build on top of it scale with multiple threads, while the scheduler incurs acceptable performance overhead in a single-threaded configuration. The scalability enabled by our scheduler is roughly on-par with that of hand-crafted application-specific locking and better than the scalability enabled by a scheduler using an off-the-shelf software transactional memory library.},
	journal = {Proc. ACM Program. Lang.},
	month = oct,
	articleno = {107},
	numpages = {30},
	keywords = {Reactive Programming, Concurrency, Transactions}
}

@article{10.1145/3236762,
	abbr = {ICFP},
	author = {Bra\v{c}evac, Oliver and Amin, Nada and Salvaneschi, Guido and Erdweg, Sebastian and Eugster, Patrick and Mezini, Mira},
	title = {Versatile Event Correlation with Algebraic Effects},
	year = {2018},
	issue_date = {September 2018},
	publisher = {Association for Computing Machinery},
	address = {New York, NY, USA},
	volume = {2},
	number = {ICFP},
	url = {https://doi.org/10.1145/3236762},
	doi = {10.1145/3236762},
	abstract = {We present the first language design to uniformly express variants of n-way joins over asynchronous event streams from different domains, e.g., stream-relational algebra, event processing, reactive and concurrent programming. We model asynchronous reactive programs and joins in direct style, on top of algebraic effects and handlers. Effect handlers act as modular interpreters of event notifications, enabling fine-grained control abstractions and customizable event matching. Join variants can be considered as cartesian product computations with ”degenerate” control flow, such that unnecessary tuples are not materialized a priori. Based on this computational interpretation, we decompose joins into a generic, naive enumeration procedure of the cartesian product, plus variant-specific extensions, represented in terms of user-supplied effect handlers. Our microbenchmarks validate that this extensible design avoids needless materialization. Alongside a formal semantics for joining and prototypes in Koka and multicore OCaml, we contribute a systematic comparison of the covered domains and features.},
	journal = {Proc. ACM Program. Lang.},
	month = jul,
	articleno = {67},
	numpages = {31},
	keywords = {joins, Koka, complex event processing, asynchrony, algebraic effect handlers, event correlation, multicore OCaml}
}

@inproceedings{10.1145/3236454.3236509,
	abbr = {SOAP},
	author = {Eichberg, M. and K\"{u}bler, F. and Helm, D. and Reif, M. and Salvaneschi, G. and Mezini, M.},
	title = {Lattice Based Modularization of Static Analyses},
	year = {2018},
	isbn = {9781450359399},
	publisher = {Association for Computing Machinery},
	address = {New York, NY, USA},
	url = {https://doi.org/10.1145/3236454.3236509},
	doi = {10.1145/3236454.3236509},
	abstract = {Static analyses which compute conceptually independent information, e.g., class immutability or method purity are typically developed as standalone, closed analyses. Complementary information that could improve the analyses is either ignored by making a sound over-approximation or it is also computed by the analyses, but at a rudimentary level. For example, an immutability analysis requires field mutability information, alias/escape information, and information about the concurrent behavior of methods to correctly classify classes like java.lang.String or java.util.BigDecimal. As a result, without properly supporting the integration of independently developed, mutually benefiting analysis, many analyses will not correctly classify relevant entities.We propose to use explicitly reified lattices that encode the information about a source code element's properties (e.g., a method's purity or a class' immutability) as the sole interface between mutually dependent analyses. This enables the composition of multiple analyses. Our case study shows that using such an approach enables highly scalable, lightweight implementations of modularized static analyses.},
	booktitle = {Companion Proceedings for the ISSTA/ECOOP 2018 Workshops},
	pages = {113–118},
	numpages = {6},
	keywords = {modularization, static analysis framework, lattice, abstract interpretation},
	location = {Amsterdam, Netherlands},
	series = {ISSTA '18}
}

@inproceedings{10.1145/3236454.3236486,
	abbr = {FTfJP},
	contributions = {ScalaLoci},
	author = {Weisenburger, Pascal and Reinhard, Tobias and Salvaneschi, Guido},
	title = {Static Latency Tracking with Placement Types},
	year = {2018},
	isbn = {9781450359399},
	publisher = {Association for Computing Machinery},
	address = {New York, NY, USA},
	url = {https://doi.org/10.1145/3236454.3236486},
	doi = {10.1145/3236454.3236486},
	abstract = {Large-scale distributed applications, e.g., in geodistributed data centers, pose a performance challenge to developers which need to take high cross-data-center latency communication cost into account. We present a preliminary investigation of a type system that tracks latency and makes the cost of remote calls explicit, raising developers' awareness of communication overhead.},
	booktitle = {Companion Proceedings for the ISSTA/ECOOP 2018 Workshops},
	pages = {34–36},
	numpages = {3},
	location = {Amsterdam, Netherlands},
	series = {ISSTA '18}
}

@inproceedings{10.1145/3210284.3210292,
	abbr = {DEBS},
	author = {Luthra, Manisha and Koldehofe, Boris and Weisenburger, Pascal and Salvaneschi, Guido and Arif, Raheel},
	title = {TCEP: Adapting to Dynamic User Environments by Enabling Transitions between Operator Placement Mechanisms},
	year = {2018},
	isbn = {9781450357821},
	publisher = {Association for Computing Machinery},
	address = {New York, NY, USA},
	url = {https://doi.org/10.1145/3210284.3210292},
	doi = {10.1145/3210284.3210292},
	abstract = {Operator placement has a profound impact on the performance of a distributed complex event processing system (DCEP). Since the behavior of a placement mechanism strongly depends on its environment; a single placement mechanism is often not enough to fulfill stringent performance requirements under environmental changes. In this paper, we show how DCEP can benefit from the adaptive use of multiple placement mechanisms. We propose Tcep, a DCEP system to integrate multiple placement mechanisms. By enabling transitions, Tcep can seamlessly exchange distinct operator mechanisms at runtime. We make two main contributions that are highly important for a cost-efficient transition: i) a transition strategy for efficiently scheduling state migrations and ii) a lightweight learning algorithm to adaptively select an appropriate placement mechanism as a consequence of a transition. Our evaluations for important decentralized placement mechanisms in the context of an IoT scenario show that transitions can better fulfill QoS demands in a dynamic environment. Thereby efficient scheduling of state migrations can help to faster complete transitions by up to 94 %.},
	booktitle = {Proceedings of the 12th ACM International Conference on Distributed and Event-Based Systems},
	pages = {136–147},
	numpages = {12},
	keywords = {Stream Processing, Adaptation, Operator Placement, Migration, Internet of Things, Complex Event Processing, Transitions},
	location = {Hamilton, New Zealand},
	series = {DEBS '18}
}

@inproceedings{10.1145/3210284.3210289,
	abbr = {DEBS},
	author = {Graubner, Pablo and Thelen, Christoph and K\"{o}rber, Michael and Sterz, Artur and Salvaneschi, Guido and Mezini, Mira and Seeger, Bernhard and Freisleben, Bernd},
	title = {Multimodal Complex Event Processing on Mobile Devices},
	year = {2018},
	isbn = {9781450357821},
	publisher = {Association for Computing Machinery},
	address = {New York, NY, USA},
	url = {https://doi.org/10.1145/3210284.3210289},
	doi = {10.1145/3210284.3210289},
	abstract = {Mobile devices are increasingly being used in edge and fog computing environments to process contextual data collected by sensors. Although complex event processing (CEP) is a suitable approach for realizing context-aware services on mobile devices in these environments, existing mobile CEP engines do not leverage the full potential of modern mobile hardware/software architectures. In this paper, we present multimodal CEP, a novel approach to process streams of events on-device in user space (user mode), in the operating system (kernel mode), on the Wi-Fi chip (Wi-Fi mode), and/or on a sensor hub (hub mode), providing significant improvements in terms of power consumption and throughput. Multimodal CEP automatically breaks up CEP queries and selects the most adequate execution mode for the involved CEP operators. Filter, aggregation, and correlation operators can be expressed in a high-level language without requiring system-level domain-specific knowledge. Multimodal CEP enables developers to efficiently detect user activities, collect environmental conditions, or interpret operating system and network events. Furthermore, it facilitates novel context-aware services, demonstrated by a use case for gathering and analyzing mobility data by Wi-Fi probe request tracking.},
	booktitle = {Proceedings of the 12th ACM International Conference on Distributed and Event-Based Systems},
	pages = {112–123},
	numpages = {12},
	keywords = {Edge/Fog Computing, Mobile Device, Complex Event Processing},
	location = {Hamilton, New Zealand},
	series = {DEBS '18}
}

@inproceedings{10.1145/3191697.3214337,
	abbr = {PX},
	contributions = {REScala},
	author = {Mogk, Ragnar and Salvaneschi, Guido and Mezini, Mira},
	title = {Reactive Programming Experience with REScala},
	year = {2018},
	isbn = {9781450355131},
	publisher = {Association for Computing Machinery},
	address = {New York, NY, USA},
	url = {https://doi.org/10.1145/3191697.3214337},
	doi = {10.1145/3191697.3214337},
	abstract = {Reactive programming is a recent programming paradigm that specifically targets reactive applications. Over the years, a number of reactive languages have been proposed, with different combinations of features, and various target domains.  Unfortunately, there is a lack of knowledge about the experience of developing software applications with reactive languages. As a result, a number of design choices in reactive programming languages remain disconnected from experience and the applicability of reactive programming to various domains remains unclear.  To bridge this gap, we report on our experience of developing reactive applications as well as teaching reactive programming in REScala, which we collected over several years of research and practice.},
	booktitle = {Conference Companion of the 2nd International Conference on Art, Science, and Engineering of Programming},
	pages = {105–112},
	numpages = {8},
	keywords = {Programming Experience, Reactive Programming, Language Design, Case Studies, Programming Paradigms},
	location = {Nice, France},
	series = {Programming'18 Companion}
}

@inproceedings{10.1145/3191697.3213804,
	abbr = {PASS},
	author = {Eichholz, Matthias and Salvaneschi, Guido and Mezini, Mira},
	title = {Towards Safe Modular Composition of Network Functions},
	year = {2018},
	isbn = {9781450355131},
	publisher = {Association for Computing Machinery},
	address = {New York, NY, USA},
	url = {https://doi.org/10.1145/3191697.3213804},
	doi = {10.1145/3191697.3213804},
	abstract = {Network Function Virtualization (NFV) aims to overcome the limitations of hardware middleboxes by moving network functions to software. Ultimately, this approach enables deployment into virtualized environments with higher flexibility, reducing deployment time and costs. In common industrial practice, multiple smaller network functions are often chained together into service function chains. Yet, service function chains are extremely fragile, lacking basic guarantees on correct composition and dependency reasoning. In this position paper, we propose a roadmap towards language abstractions that address this issue. We introduce the problems with current service function chaining technology and present the research program we envision.},
	booktitle = {Conference Companion of the 2nd International Conference on Art, Science, and Engineering of Programming},
	pages = {81–86},
	numpages = {6},
	keywords = {Network-functions, modularity, software-defined networks},
	location = {Nice, France},
	series = {Programming'18 Companion}
}

@ARTICLE{8354906,
	abbr = {Trans. Softw. Eng.},
	author = {Margara, Alessandro and Salvaneschi, Guido},
	journal = {IEEE Transactions on Software Engineering},
	title = {On the Semantics of Distributed Reactive Programming: The Cost of Consistency},
	year = {2018},
	volume = {44},
	number = {7},
	pages = {689-711},
	doi = {10.1109/TSE.2018.2833109}
}

@InProceedings{mogk_et_al:LIPIcs:2018:9206,
	abbr = {ECOOP},
	contributions = {REScala},
	author =	{Ragnar Mogk and Lars Baumg{\"a}rtner and Guido Salvaneschi and Bernd Freisleben and Mira Mezini},
	title =	{{Fault-tolerant Distributed Reactive Programming}},
	booktitle =	{32nd European Conference on Object-Oriented Programming  (ECOOP 2018)},
	pages =	{1:1--1:26},
	series =	{Leibniz International Proceedings in Informatics (LIPIcs)},
	ISBN =	{978-3-95977-079-8},
	ISSN =	{1868-8969},
	year =	{2018},
	volume =	{109},
	editor =	{Todd Millstein},
	publisher =	{Schloss Dagstuhl--Leibniz-Zentrum fuer Informatik},
	address =	{Dagstuhl, Germany},
	URL =		{http://drops.dagstuhl.de/opus/volltexte/2018/9206},
	URN =		{urn:nbn:de:0030-drops-92064},
	doi =		{10.4230/LIPIcs.ECOOP.2018.1},
	annote =	{Keywords: reactive programming, distributed systems, CRDTs, snapshots, restoration, error handling, fault tolerance}
}

@article{10.1109/TSE.2017.2655524,
	abbr = {Trans. Softw. Eng.},
	contributions = {REScala},
	author = {Salvaneschi, Guido and Proksch, Sebastian and Amann, Sven and Nadi, Sarah and Mezini, Mira},
	title = {On the Positive Effect of Reactive Programming on Software Comprehension: An Empirical Study},
	year = {2017},
	issue_date = {December 2017},
	publisher = {IEEE Press},
	volume = {43},
	number = {12},
	issn = {0098-5589},
	url = {https://doi.org/10.1109/TSE.2017.2655524},
	doi = {10.1109/TSE.2017.2655524},
	abstract = {Starting from the first investigations with strictly functional languages, reactive programming has been proposed as the programming paradigm for reactive applications. Over the years, researchers have enriched reactive languages with more powerful abstractions, embedded these abstractions into mainstream languages—including object-oriented languages—and applied reactive programming to several domains, such as GUIs, animations, Web applications, robotics, and sensor networks. However, an important assumption behind this line of research is that, beside other claimed advantages, reactive programming makes a wide class of otherwise cumbersome applications more comprehensible. This claim has never been evaluated. In this paper, we present the first empirical study that evaluates the effect of reactive programming on comprehension. The study involves&nbsp;127 subjects and compares reactive programming to the traditional object-oriented style with the Observer design pattern. Our findings show that program comprehension is significantly enhanced by the reactive-programming paradigm—a result that suggests to further develop research in this field.},
	journal = {IEEE Trans. Softw. Eng.},
	month = dec,
	pages = {1125–1143},
	numpages = {19}
}

@inproceedings{10.1145/3103111.3104044,
	abbr = {FTFJP},
	contributions = {ConSysT},
	author = {Margara, Alessandro and Salvaneschi, Guido},
	title = {Consistency Types for Safe and Efficient Distributed Programming},
	year = {2017},
	isbn = {9781450350983},
	publisher = {Association for Computing Machinery},
	address = {New York, NY, USA},
	url = {https://doi.org/10.1145/3103111.3104044},
	doi = {10.1145/3103111.3104044},
	abstract = {Consistency is a long standing problem in distributed systems. Low consistency levels are considered a necessity for scalability. High consistency is required for critical tasks such as payment and identification. Modern (geo-)distributed systems rely on the data propagation mechanisms and consistency guarantees of the distributed data store they build upon, which makes the implementation of a system that mixes different levels of consistency complex and error prone. In this paper we present preliminary work on ConSysT, a programming language that supports heterogeneous consistency specifications at the type level. In ConSysT, developers assign consistency levels directly to the data and the type system ensures the correct behavior of the application even with computations that mix data at multiple consistency levels. Our vision is that the ConSysT runtime automatically determines the most efficient mechanism to achieve the desired level of consistency among those offered by the underlying data store.},
	booktitle = {Proceedings of the 19th Workshop on Formal Techniques for Java-like Programs},
	articleno = {8},
	numpages = {2},
	location = {Barcelona, Spain},
	series = {FTFJP'17}
}

@inproceedings{10.1109/SEAMS.2017.10,
	abbr = {SEAMS},
	author = {Weisenburger, Pascal and Luthra, Manisha and Koldehofe, Boris and Salvaneschi, Guido},
	title = {Quality-Aware Runtime Adaptation in Complex Event Processing},
	year = {2017},
	isbn = {9781538615508},
	publisher = {IEEE Press},
	url = {https://doi.org/10.1109/SEAMS.2017.10},
	doi = {10.1109/SEAMS.2017.10},
	abstract = {Complex event processing (CEP) is a fundamental paradigm for a software system to self-adapt to environmental changes. CEP provides efficient means to detect (complex) events corresponding to environmental changes by performing a real-time analysis on many, possibly heterogeneous, data sources. The way current CEP systems detect events is determined at design time without accounting for dynamic changes of the environment monitored by the CEP system. This can lead to situations where the performance, quality and reliability of event detection significantly drop (e.g., due to mobility) since initial assumptions of the environment are violated or stated too general. In this paper, we propose AdaptiveCEP, a CEP system that is able to self-adapt to detected changes in environmental conditions. We propose a CEP query language that allows specifying changes in the behavior of the CEP system and its mechanisms in detecting events dependent on environmental conditions. This way, AdaptiveCEP can select the best-suited configurations for given quality demands. In our evaluation, we show by means of a reference concept how the flexibility exposed by the query language helps to achieve significant performance gains.},
	booktitle = {Proceedings of the 12th International Symposium on Software Engineering for Adaptive and Self-Managing Systems},
	pages = {140–151},
	numpages = {12},
	location = {Buenos Aires, Argentina},
	series = {SEAMS '17}
}

@inproceedings{10.1145/3001878.3001884,
	abbr = {PLATEAU},
	contributions = {REScala},
	author = {Salvaneschi, Guido},
	title = {What Do We Really Know about Data Flow Languages?},
	year = {2016},
	isbn = {9781450346382},
	publisher = {Association for Computing Machinery},
	address = {New York, NY, USA},
	url = {https://doi.org/10.1145/3001878.3001884},
	doi = {10.1145/3001878.3001884},
	abstract = { Over the last years, a number of languages based on data flow abstractions have been proposed in different important areas including Big Data, stream processing, reactive programming, real time analytics. While there is a general agreement that the data flow style simplifies the access to such complex systems compared to low level imperative APIs, this design has been substantiated by little evidence. In this paper, we advocate a systematic investigation of the design principles of data flow languages and suggest important research questions that urge to be addressed. },
	booktitle = {Proceedings of the 7th International Workshop on Evaluation and Usability of Programming Languages and Tools},
	pages = {30–31},
	numpages = {2},
	keywords = {controlled experiment, reactive programming, data flow languages},
	location = {Amsterdam, Netherlands},
	series = {PLATEAU 2016}
}

@inproceedings{10.1145/2998392.2998403,
	abbr = {SCALA},
	author = {Hauck, Markus and Savvides, Savvas and Eugster, Patrick and Mezini, Mira and Salvaneschi, Guido},
	title = {SecureScala: Scala Embedding of Secure Computations},
	year = {2016},
	isbn = {9781450346481},
	publisher = {Association for Computing Machinery},
	address = {New York, NY, USA},
	url = {https://doi.org/10.1145/2998392.2998403},
	doi = {10.1145/2998392.2998403},
	abstract = { Cloud computing offers an attractive and cost-efficient computing platform and hence it has been widely adopted by the industry and the government. At the same time, cloud computing poses a serious security challenge because sensitive data must often be outsourced to third party entities that can access the data and perform computations on them. Partial homomorphic encryption is promising for secure computation, since it allows programs to be executed over encrypted data. Despite advances in cryptographic techniques have improved the expressivity of such programs, integration with mainstream languages has seen little progress. To this end, we present SecureScala, a domain-specific language in Scala that allows expressing secure programs without requiring any cryptographic knowledge. SecureScala is based on a novel combination of free monads and free applicative functors and supports parallel execution and static analyzability. We evaluate our approach through several case studies, demonstrate its expressivity, and show that it incurs in limited performance overhead. },
	booktitle = {Proceedings of the 2016 7th ACM SIGPLAN Symposium on Scala},
	pages = {75–84},
	numpages = {10},
	keywords = {Secure computation, Domain-specific language},
	location = {Amsterdam, Netherlands},
	series = {SCALA 2016}
}

@inproceedings{10.1145/2998392.2998396,
	abbr = {SCALA},
	author = {Haller, Philipp and Geries, Simon and Eichberg, Michael and Salvaneschi, Guido},
	title = {Reactive Async: Expressive Deterministic Concurrency},
	year = {2016},
	isbn = {9781450346481},
	publisher = {Association for Computing Machinery},
	address = {New York, NY, USA},
	url = {https://doi.org/10.1145/2998392.2998396},
	doi = {10.1145/2998392.2998396},
	abstract = { Concurrent programming is infamous for its difficulty. An important source of difficulty is non-determinism, stemming from unpredictable interleavings of concurrent activities. Futures and promises are widely-used abstractions that help designing deterministic concurrent programs, although this property cannot be guaranteed statically in mainstream programming languages. Deterministic-by-construction concurrent programming models avoid this issue, but they typically restrict expressiveness in important ways.  This paper introduces a concurrent programming model, Reactive Async, which decouples concurrent computations using so-called cells, shared locations which generalize futures as well as recent deterministic abstractions such as LVars. Compared to previously proposed programming models Reactive Async provides (a) a fallback mechanism for the case where no computation ever computes the value of a given cell, and (b) explicit and optimized handling of cyclic dependencies. We present a complete implementation of the Reactive Async programming model as a library in Scala. Finally, the paper reports on a case study applying Reactive Async to static analyses of JVM bytecode based on the Opal framework. },
	booktitle = {Proceedings of the 2016 7th ACM SIGPLAN Symposium on Scala},
	pages = {11–20},
	numpages = {10},
	keywords = {concurrent programming, asynchronous programming, static analysis, deterministic concurrency, Scala},
	location = {Amsterdam, Netherlands},
	series = {SCALA 2016}
}

@inproceedings{10.1145/2908080.2908086,
	abbr = {PLDI},
	author = {Zhang, Yizhou and Salvaneschi, Guido and Beightol, Quinn and Liskov, Barbara and Myers, Andrew C.},
	title = {Accepting Blame for Safe Tunneled Exceptions},
	year = {2016},
	isbn = {9781450342612},
	publisher = {Association for Computing Machinery},
	address = {New York, NY, USA},
	url = {https://doi.org/10.1145/2908080.2908086},
	doi = {10.1145/2908080.2908086},
	abstract = { Unhandled exceptions crash programs, so a compile-time check that exceptions are handled should in principle make software more reliable. But designers of some recent languages have argued that the benefits of statically checked exceptions are not worth the costs. We introduce a new statically checked exception mechanism that addresses the problems with existing checked-exception mechanisms. In particular, it interacts well with higher-order functions and other design patterns. The key insight is that whether an exception should be treated as a "checked" exception is not a property of its type but rather of the context in which the exception propagates. Statically checked exceptions can "tunnel" through code that is oblivious to their presence, but the type system nevertheless checks that these exceptions are handled. Further, exceptions can be tunneled without being accidentally caught, by expanding the space of exception identifiers to identify the exception-handling context. The resulting mechanism is expressive and syntactically light, and can be implemented efficiently. We demonstrate the expressiveness of the mechanism using significant codebases and evaluate its performance. We have implemented this new exception mechanism as part of the new Genus programming language, but the mechanism could equally well be applied to other programming languages. },
	booktitle = {Proceedings of the 37th ACM SIGPLAN Conference on Programming Language Design and Implementation},
	pages = {281–295},
	numpages = {15},
	keywords = {Genus, Exception tunneling, exception handling},
	location = {Santa Barbara, CA, USA},
	series = {PLDI '16}
}

@inproceedings{10.1145/2889160.2893174,
	abbr = {ICSE},
	contributions = {REScala},
	author = {Salvaneschi, Guido and Mezini, Mira},
	title = {Debugging Reactive Programming with Reactive Inspector},
	year = {2016},
	isbn = {9781450342056},
	publisher = {Association for Computing Machinery},
	address = {New York, NY, USA},
	url = {https://doi.org/10.1145/2889160.2893174},
	doi = {10.1145/2889160.2893174},
	abstract = {Reactive programming provides dedicated language abstractions for reactive software, relieving developers from manually updating outputs when the inputs of a computation change. Unfortunately, complementing the new paradigm with proper tools that support coding activities is a vastly unexplored area.We investigate a primary issue in the field: debugging programs in the reactive style. We propose RP Debugging, a methodology for effectively debugging reactive programs. These ideas are implemented in Reactive Inspector, a debugger for reactive programs integrated with the Eclipse Scala development environment.},
	booktitle = {Proceedings of the 38th International Conference on Software Engineering Companion},
	pages = {728–730},
	numpages = {3},
	keywords = {debugging, functional-reactive programming},
	location = {Austin, Texas},
	series = {ICSE '16}
}

@inproceedings{10.1145/2884781.2884815,
	abbr = {ICSE},
	contributions = {REScala},
	author = {Salvaneschi, Guido and Mezini, Mira},
	title = {Debugging for Reactive Programming},
	year = {2016},
	isbn = {9781450339001},
	publisher = {Association for Computing Machinery},
	address = {New York, NY, USA},
	url = {https://doi.org/10.1145/2884781.2884815},
	doi = {10.1145/2884781.2884815},
	abstract = {Reactive programming is a recent programming technique that provides dedicated language abstractions for reactive software. Reactive programming relieves developers from manually updating outputs when the inputs of a computation change, it overcomes a number of well-know issues of the Observer design pattern, and it makes programs more comprehensible. Unfortunately, complementing the new paradigm with proper tools is a vastly unexplored area. Hence, as of now, developers can embrace reactive programming only at the cost of a more challenging development process.In this paper, we investigate a primary issue in the field: debugging programs in the reactive style. We analyze the problem of debugging reactive programs, show that the reactive style requires a paradigm shift in the concepts needed for debugging, and propose RP Debugging, a methodology for effectively debugging reactive programs. These ideas are implemented in Reactive Inspector, a debugger for reactive programs integrated with the Eclipse Scala IDE. Evaluation based on a controlled experiment shows that RP Debugging outperforms traditional debugging techniques.},
	booktitle = {Proceedings of the 38th International Conference on Software Engineering},
	pages = {796–807},
	numpages = {12},
	keywords = {functional-reactive programming, debugging},
	location = {Austin, Texas},
	series = {ICSE '16}
}

@inproceedings{10.1145/2889443.2889452,
	abbr = {MODULARITY},
	author = {Bra\v{c}evac, Oliver and Erdweg, Sebastian and Salvaneschi, Guido and Mezini, Mira},
	title = {CPL: A Core Language for Cloud Computing},
	year = {2016},
	isbn = {9781450339957},
	publisher = {Association for Computing Machinery},
	address = {New York, NY, USA},
	url = {https://doi.org/10.1145/2889443.2889452},
	doi = {10.1145/2889443.2889452},
	abstract = { Running distributed applications in the cloud involves deployment. That is, distribution and configuration of application services and middleware infrastructure. The considerable complexity of these tasks resulted in the emergence of declarative JSON-based domain-specific deployment languages to develop deployment programs. However, existing deployment programs unsafely compose artifacts written in different languages, leading to bugs that are hard to detect before run time. Furthermore, deployment languages do not provide extension points for custom implementations of existing cloud services such as application-specific load balancing policies. To address these shortcomings, we propose CPL (Cloud Platform Language), a statically-typed core language for programming both distributed applications as well as their deployment on a cloud platform. In CPL, application services and deployment programs interact through statically typed, extensible interfaces, and an application can trigger further deployment at run time. We provide a formal semantics of CPL and demonstrate that it enables type-safe, composable and extensible libraries of service combinators, such as load balancing and fault tolerance. },
	booktitle = {Proceedings of the 15th International Conference on Modularity},
	pages = {94–105},
	numpages = {12},
	keywords = {cloud computing, join calculus, computation patterns, Cloud deployment},
	location = {M\'{a}laga, Spain},
	series = {MODULARITY 2016}
}

@inproceedings{10.1145/2984043.2984051,
	contributions = {ScalaLoci},
	author = {Weisenburger, Pascal},
	title = {Multitier Reactive Abstractions},
	year = {2016},
	isbn = {9781450344371},
	publisher = {Association for Computing Machinery},
	address = {New York, NY, USA},
	url = {https://doi.org/10.1145/2984043.2984051},
	doi = {10.1145/2984043.2984051},
	abstract = { Distributed applications are traditionally developed using separate modules for each component in the distributed system, which can even be written in different programming languages. Those modules react on events such as user input, which are produced by other modules, and may in turn produce new events to be handled by different modules. Thus, most distributed applications are reactive in nature. Distributed event-based data flow makes it is hard to reason about the system and therefore makes the development of distributed systems challenging.  In this paper, we present language abstractions for distributed reactive programming easing the development of such applications and supporting various distributed architectures. },
	booktitle = {Companion Proceedings of the 2016 ACM SIGPLAN International Conference on Systems, Programming, Languages and Applications: Software for Humanity},
	pages = {18–20},
	numpages = {3},
	keywords = {Distributed Programming, Reactive Programming},
	location = {Amsterdam, Netherlands},
	series = {SPLASH Companion 2016}
}

@inproceedings{10.1145/2737924.2738008,
	abbr = {PLDI},
	author = {Zhang, Yizhou and Loring, Matthew C. and Salvaneschi, Guido and Liskov, Barbara and Myers, Andrew C.},
	title = {Lightweight, Flexible Object-Oriented Generics},
	year = {2015},
	isbn = {9781450334686},
	publisher = {Association for Computing Machinery},
	address = {New York, NY, USA},
	url = {https://doi.org/10.1145/2737924.2738008},
	doi = {10.1145/2737924.2738008},
	abstract = { The support for generic programming in modern object-oriented programming languages is awkward and lacks desirable expressive power. We introduce an expressive genericity mechanism that adds expressive power and strengthens static checking, while remaining lightweight and simple in common use cases. Like type classes and concepts, the mechanism allows existing types to model type constraints retroactively. For expressive power, we expose models as named constructs that can be defined and selected explicitly to witness constraints; in common uses of genericity, however, types implicitly witness constraints without additional programmer effort. Models are integrated into the object-oriented style, with features like model generics, model-dependent types, model enrichment, model multimethods, constraint entailment, model inheritance, and existential quantification further extending expressive power in an object-oriented setting. We introduce the new genericity features and show that common generic programming idioms, including current generic libraries, can be expressed more precisely and concisely. The static semantics of the mechanism and a proof of a key decidability property can be found in an associated technical report. },
	booktitle = {Proceedings of the 36th ACM SIGPLAN Conference on Programming Language Design and Implementation},
	pages = {436–445},
	numpages = {10},
	keywords = {generic programming, constraints, models, Genus},
	location = {Portland, OR, USA},
	series = {PLDI '15}
}

@inproceedings{10.5555/2819009.2819226,
	abbr = {ICSE},
	contributions = {REScala},
	author = {Salvaneschi, Guido and Margara, Alessandro and Tamburrelli, Giordano},
	title = {Reactive Programming: A Walkthrough},
	year = {2015},
	publisher = {IEEE Press},
	abstract = {Over the last few years, Reactive Programming has emerged as the trend to support the development of reactive software through dedicated programming abstractions. Reactive Programming has been increasingly investigated in the programming languages community and it is now gaining the interest of practitioners. Conversely, it has received so far less attention from the software engineering community.This technical briefing bridges this gap through an accurate overview of Reactive Programming, discussing the available frameworks and outlining open research challenges with an emphasis on cross-field research opportunities.},
	booktitle = {Proceedings of the 37th International Conference on Software Engineering - Volume 2},
	pages = {953–954},
	numpages = {2},
	location = {Florence, Italy},
	series = {ICSE '15}
}

@article{10.1016/j.scico.2014.11.016,
	abbr = {Sci. Comput. Program.},
	author = {Salvaneschi, Guido and Ghezzi, Carlo and Pradella, Matteo},
	title = {ContextErlang},
	year = {2015},
	issue_date = {May 2015},
	publisher = {Elsevier North-Holland, Inc.},
	address = {USA},
	volume = {102},
	number = {C},
	issn = {0167-6423},
	url = {https://doi.org/10.1016/j.scico.2014.11.016},
	doi = {10.1016/j.scico.2014.11.016},
	abstract = {Self-adaptive software modifies its behavior at run time to satisfy changing requirements in a dynamic environment. Context-oriented programming (COP) has been recently proposed as a specialized programming paradigm for context-aware and adaptive systems. COP mostly focuses on run time adaptation of the application's behavior by supporting modular descriptions of behavioral variations. However, self-adaptive applications must satisfy additional requirements, such as distribution and concurrency, support for unforeseen changes and enforcement of correct behavior in the presence of dynamic change. Addressing these issues at the language level requires a holistic design that covers all aspects and takes into account the possibly cumbersome interaction of those features, for example concurrency and dynamic change.We present ContextErlang, a COP programming language in which adaptive abstractions are seamlessly integrated with distribution and concurrency. We define ContextErlang's formal semantics, validated through an executable prototype, and we show how it supports formal proofs that the language design ensures satisfaction of certain safety requirements. We provide empirical evidence that ContextErlang is an effective solution through case studies and a performance assessment. We also show how the same design principles that lead to the development of ContextErlang can be followed to systematically design contextual extensions of other languages. A concrete example is presented concerning ContextScala.},
	journal = {Sci. Comput. Program.},
	month = may,
	pages = {20–43},
	numpages = {24},
	keywords = {Context, Context-oriented programming, Distribution, Concurrency, Self-adaptive software}
}

@inproceedings{10.1145/2635868.2635895,
	abbr = {FSE},
	contributions = {REScala},
	author = {Salvaneschi, Guido and Amann, Sven and Proksch, Sebastian and Mezini, Mira},
	title = {An Empirical Study on Program Comprehension with Reactive Programming},
	year = {2014},
	isbn = {9781450330565},
	publisher = {Association for Computing Machinery},
	address = {New York, NY, USA},
	url = {https://doi.org/10.1145/2635868.2635895},
	doi = {10.1145/2635868.2635895},
	abstract = { Starting from the first investigations with strictly functional languages, reactive programming has been proposed as THE programming paradigm for reactive applications. The advantages of designs based on this style over designs based on the Observer design pattern have been studied for a long time. Over the years, researchers have enriched reactive languages with more powerful abstractions, embedded these abstractions into mainstream languages – including object-oriented languages – and applied reactive programming to several domains, like GUIs, animations, Web applications, robotics, and sensor networks. However, an important assumption behind this line of research – that, beside other advantages, reactive programming makes a wide class of otherwise cumbersome applications more comprehensible – has never been evaluated. In this paper, we present the design and the results of the first empirical study that evaluates the effect of reactive programming on comprehensibility compared to the traditional object-oriented style with the Observer design pattern. Results confirm the conjecture that comprehensibility is enhanced by reactive programming. In the experiment, the reactive programming group significantly outperforms the other group. },
	booktitle = {Proceedings of the 22nd ACM SIGSOFT International Symposium on Foundations of Software Engineering},
	pages = {564–575},
	numpages = {12},
	keywords = {Reactive Programming, Empirical Study, Controlled Experiment},
	location = {Hong Kong, China},
	series = {FSE 2014}
}

@inproceedings{10.1145/2660193.2660242,
	abbr = {OOPSLA},
	author = {Mitschke, Ralf and Erdweg, Sebastian and K\"{o}hler, Mirko and Mezini, Mira and Salvaneschi, Guido},
	title = {I3QL: Language-Integrated Live Data Views},
	year = {2014},
	isbn = {9781450325851},
	publisher = {Association for Computing Machinery},
	address = {New York, NY, USA},
	url = {https://doi.org/10.1145/2660193.2660242},
	doi = {10.1145/2660193.2660242},
	abstract = {An incremental computation updates its result based on a change to its input, which is often an order of magnitude faster than a recomputation from scratch. In particular, incrementalization can make expensive computations feasible for settings that require short feedback cycles, such as interactive systems, IDEs, or (soft) real-time systems.This paper presents i3QL, a general-purpose programming language for specifying incremental computations. i3QL provides a declarative SQL-like syntax and is based on incremental versions of operators from relational algebra, enriched with support for general recursion. We integrated i3QL into Scala as a library, which enables programmers to use regular Scala code for non-incremental subcomputations of an i3QL query and to easily integrate incremental computations into larger software projects. To improve performance, i3QL optimizes user-defined queries by applying algebraic laws and partial evaluation. We describe the design and implementation of i3QL and its optimizations, demonstrate its applicability, and evaluate its performance.},
	booktitle = {Proceedings of the 2014 ACM International Conference on Object Oriented Programming Systems Languages &amp; Applications},
	pages = {417–432},
	numpages = {16},
	keywords = {reactive programming, scala, incremental computation},
	location = {Portland, Oregon, USA},
	series = {OOPSLA '14}
}

@inproceedings{10.1145/2660193.2660240,
	abbr = {OOPSLA},
	contributions = {REScala},
	author = {Drechsler, Joscha and Salvaneschi, Guido and Mogk, Ragnar and Mezini, Mira},
	title = {Distributed REScala: An Update Algorithm for Distributed Reactive Programming},
	year = {2014},
	isbn = {9781450325851},
	publisher = {Association for Computing Machinery},
	address = {New York, NY, USA},
	url = {https://doi.org/10.1145/2660193.2660240},
	doi = {10.1145/2660193.2660240},
	abstract = {Reactive programming improves the design of reactive applications by relocating the logic for managing dependencies between dependent values away from the application logic to the language implementation. Many distributed applications are reactive. Yet, existing change propagation algorithms are not suitable in a distributed setting.We propose Distributed REScala, a reactive language with a change propagation algorithm that works without centralized knowledge about the topology of the dependency structure among reactive values and avoids unnecessary propagation of changes, while retaining safety guarantees (glitch freedom). Distributed REScala enables distributed reactive programming, bringing the benefits of reactive programming to distributed applications. We demonstrate the enabled design improvements by a case study. We also empirically evaluate the performance of our algorithm in comparison to other algorithms in a simulated distributed setting.},
	booktitle = {Proceedings of the 2014 ACM International Conference on Object Oriented Programming Systems Languages &amp; Applications},
	pages = {361–376},
	numpages = {16},
	keywords = {distributed programming, scala, reactive programming},
	location = {Portland, Oregon, USA},
	series = {OOPSLA '14}
}

@inproceedings{10.1145/2611286.2611290,
	abbr = {DEBS},
	contributions = {ConSysT},
	author = {Margara, Alessandro and Salvaneschi, Guido},
	title = {We Have a DREAM: Distributed Reactive Programming with Consistency Guarantees},
	year = {2014},
	isbn = {9781450327374},
	publisher = {Association for Computing Machinery},
	address = {New York, NY, USA},
	url = {https://doi.org/10.1145/2611286.2611290},
	doi = {10.1145/2611286.2611290},
	abstract = {The reactive programming paradigm has been proposed to simplify the development of reactive systems. It relies on programming primitives to express dependencies between data items and on runtime/middleware support for automated propagation of changes. Despite this paradigm is receiving increasing attention, defining the precise semantics and the consistency guarantees for reactive programming in distributed environments is an open research problem.This paper targets such problem by studying the consistency guarantees for the propagation of changes in a distributed reactive system. In particular, it introduces three propagation semantics, namely causal, glitch free, and atomic, providing different trade-offs between costs and guarantees. Furthermore, it describes how these semantics are concretely implemented in a Distributed REActice Middleware (DREAM), which exploits a distributed event-based dispatching system to propagate changes.We compare the performance of DREAM in a wide range of scenarios. This allows us to study the overhead introduced by the different semantics in terms of network traffic and propagation delay and to assess the efficiency of DREAM in supporting distributed reactive systems.},
	booktitle = {Proceedings of the 8th ACM International Conference on Distributed Event-Based Systems},
	pages = {142–153},
	numpages = {12},
	keywords = {distributed reactive programming, event-based middleware, glitch-freedom, consistency guarantees, dream},
	location = {Mumbai, India},
	series = {DEBS '14}
}

@inproceedings{10.1145/2577080.2577083,
	abbr = {MODULARITY},
	contributions = {REScala},
	author = {Salvaneschi, Guido and Hintz, Gerold and Mezini, Mira},
	title = {REScala: Bridging between Object-Oriented and Functional Style in Reactive Applications},
	year = {2014},
	isbn = {9781450327725},
	publisher = {Association for Computing Machinery},
	address = {New York, NY, USA},
	url = {https://doi.org/10.1145/2577080.2577083},
	doi = {10.1145/2577080.2577083},
	abstract = {Traditionally, object-oriented software adopts the Observer pattern to implement reactive behavior. Its drawbacks are well-documented and two families of alternative approaches have been proposed, extending object-oriented languages with concepts from functional reactive and dataflow programming, respectively event-driven programming. The former hardly escape the functional setting; the latter do not achieve the declarativeness of more functional approaches.In this paper, we present REScala, a reactive language which integrates concepts from event-based and functional-reactive programming into the object-oriented world. REScala supports the development of reactive applications by fostering a functional declarative style which complements the advantages of object-oriented design.},
	booktitle = {Proceedings of the 13th International Conference on Modularity},
	pages = {25–36},
	numpages = {12},
	keywords = {scala, event-driven programming, functional-reactive programming},
	location = {Lugano, Switzerland},
	series = {MODULARITY '14}
}

@inproceedings{10.1145/2577080.2577082,
	abbr = {MODULARITY},
	contributions = {REScala},
	author = {Van Ham, Jurgen M. and Salvaneschi, Guido and Mezini, Mira and Noy\'{e}, Jacques},
	title = {JEScala: Modular Coordination with Declarative Events and Joins},
	year = {2014},
	isbn = {9781450327725},
	publisher = {Association for Computing Machinery},
	address = {New York, NY, USA},
	url = {https://doi.org/10.1145/2577080.2577082},
	doi = {10.1145/2577080.2577082},
	abstract = {Advanced concurrency abstractions overcome the drawbacks of low-level techniques such as locks and monitors, freeing programmers that implement concurrent applications from the burden of concentrating on low-level details. However, with current approaches the coordination logic involved in complex coordination schemas is fragmented into several pieces including join patterns, data emissions triggered in different places of the application, and the application logic that implicitly creates dependencies among communication channels, hence indirectly among join patterns. We present JEScala, a language that captures coordination schemas in a more expressive and modular way by leveraging a seamless integration of an advanced event system with join abstractions. We validate our approach with case studies and provide a first performance assessment.},
	booktitle = {Proceedings of the 13th International Conference on Modularity},
	pages = {205–216},
	numpages = {12},
	keywords = {concurrency, join patterns, scala, event-driven programming},
	location = {Lugano, Switzerland},
	series = {MODULARITY '14}
}

@Inbook{Salvaneschi2014,
	contributions={REScala},
	author="Salvaneschi, Guido
	and Mezini, Mira",
	editor="Chiba, Shigeru
	and Tanter, {\'E}ric
	and Bodden, Eric
	and Maoz, Shahar
	and Kienzle, J{\"o}rg",
	title="Towards Reactive Programming for Object-Oriented Applications",
	bookTitle="Transactions on Aspect-Oriented Software Development XI",
	year="2014",
	publisher="Springer Berlin Heidelberg",
	address="Berlin, Heidelberg",
	pages="227--261",
	abstract="Reactive applications are difficult to implement. Traditional solutions based on event systems and the Observer pattern have a number of inconveniences, but programmers bear them in return for the benefits of OO design. On the other hand, reactive approaches based on automatic updates of dependencies -- like functional reactive programming and dataflow languages -- provide undoubted advantages but do not fit well with mutable objects.",
	isbn="978-3-642-55099-7",
	doi="10.1007/978-3-642-55099-7_7",
	url="https://doi.org/10.1007/978-3-642-55099-7_7"
}

@ARTICLE{6840828,
	abbr = {Software},
	author={Salvaneschi, Guido and Eugster, Patrick and Mezini, Mira},
	journal={IEEE Software},
	title={Programming with Implicit Flows},
	year={2014},
	volume={31},
	number={5},
	pages={52-59},
	doi={10.1109/MS.2014.101}
}

@article{10.1145/2491465.2491466,
	abbr = {Trans. Auton. Adapt. Syst.},
	author = {Salvaneschi, Guido and Ghezzi, Carlo and Pradella, Matteo},
	title = {An Analysis of Language-Level Support for Self-Adaptive Software},
	year = {2013},
	issue_date = {July 2013},
	publisher = {Association for Computing Machinery},
	address = {New York, NY, USA},
	volume = {8},
	number = {2},
	issn = {1556-4665},
	url = {https://doi.org/10.1145/2491465.2491466},
	doi = {10.1145/2491465.2491466},
	abstract = {Self-adaptive software has become increasingly important to address the new challenges of complex computing systems. To achieve adaptation, software must be designed and implemented by following suitable criteria, methods, and strategies. Past research has been mostly addressing adaptation by developing solutions at the software architecture level. This work, instead, focuses on finer-grain programming language-level solutions. We analyze three main linguistic approaches: metaprogramming, aspect-oriented programming, and context-oriented programming. The first two are general-purpose linguistic mechanisms, whereas the third is a specific and focused approach developed to support context-aware applications. This paradigm provides specialized language-level abstractions to implement dynamic adaptation and modularize behavioral variations in adaptive systems.The article shows how the three approaches can support the implementation of adaptive systems and compares the pros and cons offered by each solution.},
	journal = {ACM Trans. Auton. Adapt. Syst.},
	month = jul,
	articleno = {7},
	numpages = {29},
	keywords = {self-adaptive software, context-oriented programming, autonomic computing, Context}
}

@inproceedings{10.1145/2451436.2451442,
	abbr = {AOSD},
	contributions = {REScala},
	author = {Salvaneschi, Guido and Mezini, Mira},
	title = {Reactive Behavior in Object-Oriented Applications: An Analysis and a Research Roadmap},
	year = {2013},
	isbn = {9781450317665},
	publisher = {Association for Computing Machinery},
	address = {New York, NY, USA},
	url = {https://doi.org/10.1145/2451436.2451442},
	doi = {10.1145/2451436.2451442},
	abstract = {Reactive applications are difficult to implement. Traditional solutions based on event systems and the Observer pattern have a number of inconveniences, but programmers bear them in return for the benefits of OO design. On the other hand, reactive approaches based on automatic updates of dependencies - like functional reactive programming and dataflow languages - provide undoubted advantages but do not fit well with mutable objects. In this paper, we provide a research roadmap to overcome the limitations of the current approaches and to support reactive applications in the OO setting. To establish a solid background for our investigation, we propose a conceptual framework to model the design space of reactive applications and we study the flaws of the existing solutions. Then we highlight how reactive languages have the potential to address those issues and we formulate our research plan.},
	booktitle = {Proceedings of the 12th Annual International Conference on Aspect-Oriented Software Development},
	pages = {37–48},
	numpages = {12},
	keywords = {functional-reactive programming, reactive programming, object-oriented programming, incremental computation},
	location = {Fukuoka, Japan},
	series = {AOSD '13}
}

@unpublished{REM2013,
	abbr = {REM},
	contributions = {REScala},
	title = {Ways to React: Comparing Reactive Languages and Complex Event},
	author = {Margara, Alessandro and Salvaneschi, Guido},
	year = {2013}
}

@InProceedings{10.1007/978-3-642-38493-6_16,
	abbr={COORDINATION},
	contributions={REScala},
	author="Salvaneschi, Guido
	and Drechsler, Joscha
	and Mezini, Mira",
	editor="De Nicola, Rocco
	and Julien, Christine",
	title="Towards Distributed Reactive Programming",
	booktitle="Coordination Models and Languages",
	year="2013",
	publisher="Springer Berlin Heidelberg",
	address="Berlin, Heidelberg",
	pages="226--235",
	abstract="Reactive applications is a wide class of software that responds to user input, network messages, and other events. Recent research on reactive languages successfully addresses the drawbacks of the Observer pattern -- the traditional way reactive applications are implemented in the object-oriented setting -- by introducing time-changing values and other ad-hoc programming abstractions.",
	isbn="978-3-642-38493-6"
}

@article{10.1016/j.jss.2012.03.024,
	abbr = {Syst. Softw.},
	author = {Salvaneschi, Guido and Ghezzi, Carlo and Pradella, Matteo},
	title = {Context-Oriented Programming: A Software Engineering Perspective},
	year = {2012},
	issue_date = {August, 2012},
	publisher = {Elsevier Science Inc.},
	address = {USA},
	volume = {85},
	number = {8},
	issn = {0164-1212},
	url = {https://doi.org/10.1016/j.jss.2012.03.024},
	doi = {10.1016/j.jss.2012.03.024},
	abstract = {The implementation of context-aware systems can be supported through the adoption of techniques at the architectural level such as middlewares or component-oriented architectures. It can also be supported by suitable constructs at the programming language level. Context-oriented programming (COP) is emerging as a novel paradigm for the implementation of this kind of software, in particular in the field of mobile and ubiquitous computing. The COP paradigm tackles the issue of developing context-aware systems at the language-level, introducing ad hoc language abstractions to manage adaptations modularization and their dynamic activation. In this paper we review the state of the art in the field of COP in the perspective of the benefits that this technique can provide to software engineers in the design and implementation of context-aware applications.},
	journal = {J. Syst. Softw.},
	month = aug,
	pages = {1801–1817},
	numpages = {17},
	keywords = {Context-oriented programming, Context, Context-awareness}
}

@inproceedings{10.1145/2162049.2162072,
	abbr = {AOSD},
	author = {Salvaneschi, Guido and Ghezzi, Carlo and Pradella, Matteo},
	title = {ContextErlang: Introducing Context-Oriented Programming in the Actor Model},
	year = {2012},
	isbn = {9781450310925},
	publisher = {Association for Computing Machinery},
	address = {New York, NY, USA},
	url = {https://doi.org/10.1145/2162049.2162072},
	doi = {10.1145/2162049.2162072},
	abstract = {Self-adapting systems are becoming widespread in emerging fields such as autonomic, mobile and ubiquitous computing. Context-oriented programming (COP) is a promising language-level solution for the implementation of context-aware, self-adaptive software. However, current COP approaches struggle to effectively manage the asynchronous nature of context provisioning. We argue that, to solve these issues, COP features should be designed to fit nicely in the concurrency model supported by the language. This work presents the design rationale of ContextErlang, which introduces COP in the Actor Model. We provide evidence that ContextErlang constitutes a viable solution to implement context-aware software in a highly concurrent and distributed setting. We discuss a case study and an evaluation of run-time performance.},
	booktitle = {Proceedings of the 11th Annual International Conference on Aspect-Oriented Software Development},
	pages = {191–202},
	numpages = {12},
	keywords = {self-adaptive software, Erlang, OTP platform, context-oriented programming},
	location = {Potsdam, Germany},
	series = {AOSD '12}
}

@inproceedings{10.1007/978-3-642-25560-1_10,
	abbr = {ICISS},
	author = {Maggi, Federico and Bellini, Andrea and Salvaneschi, Guido and Zanero, Stefano},
	title = {Finding Non-Trivial Malware Naming Inconsistencies},
	year = {2011},
	isbn = {9783642255595},
	publisher = {Springer-Verlag},
	address = {Berlin, Heidelberg},
	url = {https://doi.org/10.1007/978-3-642-25560-1_10},
	doi = {10.1007/978-3-642-25560-1_10},
	abstract = {Malware analysts, and in particular antivirus vendors, never agreed on a single naming convention for malware specimens. This leads to confusion and difficulty—more for researchers than for practitioners—for example, when comparing coverage of different antivirus engines, when integrating and systematizing known threats, or comparing the classifications given by different detectors. Clearly, solving naming inconsistencies is a very difficult task, as it requires that vendors agree on a unified naming convention. More importantly, solving inconsistencies is impossible without knowing exactly where they are. Therefore, in this paper we take a step back and concentrate on the problem of finding inconsistencies. To this end, we first represent each vendor's naming convention with a graph-based model. Second, we give a precise definition of inconsistency with respect to these models. Third, we define two quantitative measures to calculate the overall degree of inconsistency between vendors. In addition, we propose a fast algorithm that finds non-trivial (i.e., beyond syntactic differences) inconsistencies. Our experiments on four major antivirus vendors and 98,798 real-world malware samples confirm anecdotal observations that different vendors name viruses differently. More importantly, we were able to find inconsistencies that cannot be inferred at all by looking solely at the syntax.},
	booktitle = {Proceedings of the 7th International Conference on Information Systems Security},
	pages = {144–159},
	numpages = {16},
	location = {Kolkata, India},
	series = {ICISS'11}
}

@inproceedings{10.1145/2068736.2068740,
	abbr = {COP},
	author = {Salvaneschi, Guido and Ghezzi, Carlo and Pradella, Matteo},
	title = {JavaCtx: Seamless Toolchain Integration for Context-Oriented Programming},
	year = {2011},
	isbn = {9781450308915},
	publisher = {Association for Computing Machinery},
	address = {New York, NY, USA},
	url = {https://doi.org/10.1145/2068736.2068740},
	doi = {10.1145/2068736.2068740},
	abstract = {Context-oriented programming is an emerging paradigm addressing at the language level the issue of dynamic software adaptation and modularization of context-specific concerns. In this paper we propose JavaCtx, a tool which employs coding conventions to generate the context-aware semantics for Java programs and subsequently weave it into the application. The contribution of JavaCtx is twofold: the design of a set of coding conventions which allow to write context-oriented software in plain Java and the concept of context-oriented semantics injection, which allows to introduce the context-aware semantics through standard aspect-oriented programming. Both of these points allow to seamless integrate JavaCtx in the existing industrial-strength appliances and so ease the development of context-oriented software in consolidated industrial settings.},
	booktitle = {Proceedings of the 3rd International Workshop on Context-Oriented Programming},
	articleno = {4},
	numpages = {6},
	keywords = {self-adaptive software, context-oriented programming, context, aspect-oriented programming},
	location = {Lancaster, United Kingdom},
	series = {COP '11}
}

@inproceedings{10.1145/1988008.1988016,
	abbr = {SEAMS},
	author = {Ghezzi, Carlo and Pradella, Matteo and Salvaneschi, Guido},
	title = {An Evaluation of the Adaptation Capabilities in Programming Languages},
	year = {2011},
	isbn = {9781450305754},
	publisher = {Association for Computing Machinery},
	address = {New York, NY, USA},
	url = {https://doi.org/10.1145/1988008.1988016},
	doi = {10.1145/1988008.1988016},
	abstract = {In recent years the need for software applications to adapt to the environment in which they are situated has become common. Beside architectural approaches, language-level support for the development of adaptable and context-aware software have been investigated. Many existing solutions adopt ad hoc programming paradigms such as aspect oriented programming (AOP) or context oriented programming (COP). In this paper we investigate the use of the abstractions offered by traditional object-oriented and functional paradigms for the development of context-adaptable systems. We carry out our analysis along a set of conceptual directions which consider the requirement of functional adaptation beside non functional requirements such as safety and effective modularization. Our analysis were validated though the development of several prototypes of an adaptable cache server which is chosen as the running example through the paper. We provide an estimation of the performance advantages of the techniques based traditional programming languages compared with context-oriented programming.},
	booktitle = {Proceedings of the 6th International Symposium on Software Engineering for Adaptive and Self-Managing Systems},
	pages = {50–59},
	numpages = {10},
	keywords = {self-adaptive software, context, context-oriented programming},
	location = {Waikiki, Honolulu, HI, USA},
	series = {SEAMS '11}
}

@incollection{DBLP:reference/crypt/SalvaneschiS11,
	author    = {Guido Salvaneschi and
	           Paolo Salvaneschi},
	editor    = {Henk C. A. van Tilborg and
	           Sushil Jajodia},
	title     = {Metrics of Software Security},
	booktitle = {Encyclopedia of Cryptography and Security, 2nd Ed},
	pages     = {775--778},
	publisher = {Springer},
	year      = {2011},
	url       = {https://doi.org/10.1007/978-1-4419-5906-5\_680},
	doi       = {10.1007/978-1-4419-5906-5\_680},
	timestamp = {Wed, 12 Jul 2017 09:11:27 +0200},
	biburl    = {https://dblp.org/rec/reference/crypt/SalvaneschiS11.bib},
	bibsource = {dblp computer science bibliography, https://dblp.org}
}


@article{DBLP:journals/corr/abs-1105-0069,
	abbr = {CoRR},
	author    = {Guido Salvaneschi and
	           Carlo Ghezzi and
	           Matteo Pradella},
	title     = {Context-Oriented Programming: {A} Programming Paradigm for Autonomic
	           Systems},
	journal   = {CoRR},
	volume    = {abs/1105.0069},
	year      = {2011},
	url       = {http://arxiv.org/abs/1105.0069},
	archivePrefix = {arXiv},
	eprint    = {1105.0069},
	timestamp = {Mon, 13 Aug 2018 16:47:40 +0200},
	biburl    = {https://dblp.org/rec/journals/corr/abs-1105-0069.bib},
	bibsource = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{10.1145/1930021.1930022,
	abbr = {COP},
	author = {Ghezzi, Carlo and Pradella, Matteo and Salvaneschi, Guido},
	title = {Context Oriented Programming in Highly Concurrent Systems},
	year = {2010},
	isbn = {9781450305310},
	publisher = {Association for Computing Machinery},
	address = {New York, NY, USA},
	url = {https://doi.org/10.1145/1930021.1930022},
	doi = {10.1145/1930021.1930022},
	abstract = {Context Oriented Programming (COP) allows modularization of programs according to the cross-cutting concern of contexts. Context depending features are grouped in layers which can be activated at run time by triggering the associated behavioral variations.COP extensions have been provided for different languages. However all of them enforce a thread, shared-memory based concurrency model. In this paper we discuss how the COP paradigm can be applied to message-based concurrent systems which support the agents paradigm. The discussion is supported by the case of ContextErlang, our COP-inspired contextual version of Erlang.},
	booktitle = {Proceedings of the 2nd International Workshop on Context-Oriented Programming},
	articleno = {1},
	numpages = {3},
	keywords = {context-oriented programming, self-adaptive software, Erlang, OTP platform, context},
	location = {Maribor, Slovenia},
	series = {COP '10}
}

@inproceedings{10.1109/SP.2010.12,
	abbr = {SP},
	author = {Comparetti, Paolo Milani and Salvaneschi, Guido and Kirda, Engin and Kolbitsch, Clemens and Kruegel, Christopher and Zanero, Stefano},
	title = {Identifying Dormant Functionality in Malware Programs},
	year = {2010},
	isbn = {9780769540351},
	publisher = {IEEE Computer Society},
	address = {USA},
	url = {https://doi.org/10.1109/SP.2010.12},
	doi = {10.1109/SP.2010.12},
	abstract = {To handle the growing flood of malware, security vendors and analysts rely on tools that automatically identify and analyze malicious code. Current systems for automated malware analysis typically follow a dynamic approach, executing an unknown program in a controlled environment (sandbox) and recording its runtime behavior. Since dynamic analysis platforms directly run malicious code, they are resilient to popular malware defense techniques such as packing and code obfuscation. Unfortunately, in many cases, only a small subset of all possible malicious behaviors is observed within the short time frame that a malware sample is executed. To mitigate this issue, previous work introduced techniques such as multi-path or forced execution to increase the coverage of dynamic malware analysis. Unfortunately, using these techniques is potentially expensive, as the number of paths that require analysis can grow exponentially. In this paper, we propose Reanimator, a novel solution to determine the capabilities (malicious functionality) of malware programs. Our solution is based on the insight that we can leverage behavior observed while dynamically executing a specific malware sample to identify similar functionality in other programs. More precisely, when we observe malicious actions during dynamic analysis, we automatically extract and model the parts of the malware binary that are responsible for this behavior. We then leverage these models to check whether similar code is present in other samples. This allows us to statically identify dormant functionality (functionality that is not observed during dynamic analysis) in malicious programs. We evaluate our approach on thousands of real-world malware samples, and we show that our system is successful in identifying additional, malicious functionality. As a result, our approach can significantly improve the coverage of malware analysis results.},
	booktitle = {Proceedings of the 2010 IEEE Symposium on Security and Privacy},
	pages = {61–76},
	numpages = {16},
	keywords = {malware analysis, dormant functionality, binary analysis},
	series = {SP '10}
}

@inproceedings{10.1145/1808984.1808991,
	abbr = {SEAMS},
	author = {Ghezzi, Carlo and Pradella, Matteo and Salvaneschi, Guido},
	title = {Programming Language Support to Context-Aware Adaptation: A Case-Study with Erlang},
	year = {2010},
	isbn = {9781605589718},
	publisher = {Association for Computing Machinery},
	address = {New York, NY, USA},
	url = {https://doi.org/10.1145/1808984.1808991},
	doi = {10.1145/1808984.1808991},
	abstract = {Software applications are increasingly situated in a world where context changes continuously. At the same time, applications need to provide continuous service, and the service provided often needs to change in order to adapt to the new contexts. Context-aware adaptation can be greatly facilitated by using programming languages that natively support high-level features to deal with contexts, context changes, and context-aware behaviors. Although context-oriented programming has been around for a while, most existing efforts focus on incorporating context-oriented features in languages that are not primarily oriented to concurrency, distribution, and dynamic reconfiguration. These features, however, characterize most pervasive context-aware situations. In this work, we illustrate how context-aware programming primitives may introduced in the parallel and distributed Erlang programming language. We also present an extended example, which illustrates the benefits of using our extension (ContextErlang) to design context-aware pervasive applications.},
	booktitle = {Proceedings of the 2010 ICSE Workshop on Software Engineering for Adaptive and Self-Managing Systems},
	pages = {59–68},
	numpages = {10},
	keywords = {Erlang, context-oriented programming, context, self-adaptative software, OTP platform},
	location = {Cape Town, South Africa},
	series = {SEAMS '10}
}

@inproceedings{10.1007/978-3-642-12029-9_17,
	abbr = {FASE},
	author = {Ghezzi, Carlo and Mocci, Andrea and Salvaneschi, Guido},
	title = {Automatic Cross Validation of Multiple Specifications: A Case Study},
	year = {2010},
	isbn = {3642120288},
	publisher = {Springer-Verlag},
	address = {Berlin, Heidelberg},
	url = {https://doi.org/10.1007/978-3-642-12029-9_17},
	doi = {10.1007/978-3-642-12029-9_17},
	abstract = {The problem of formal software specification has been addressed and discussed since the infancy of software engineering. However, among all the proposed solutions, none is universally accepted yet. Many different formal descriptions can in fact be given for the same software component; thus, the problem of determining the consistency relation among those descriptions becomes relevant and potentially critical. In this work, we propose a method for comparing two specific kinds of formal specifications of containers. In particular, we check the consistency of intensional behavior models with algebraic specifications. The consistency check is performed by generating a behavioral equivalence model from the intensional model, converting the algebraic axioms into temporal logic formulae, and then checking them against the model by using the NuSMV model checker. An automated software tool which encodes the problem as model checking has been implemented to check the consistency of recovered specifications of relevant Java classes.},
	booktitle = {Proceedings of the 13th International Conference on Fundamental Approaches to Software Engineering},
	pages = {233–247},
	numpages = {15},
	location = {Paphos, Cyprus},
	series = {FASE'10}
}

@inproceedings{10.1109/EC2ND.2009.13,
	abbr = {EC2ND},
	author = {Criscione, C. and Salvaneschi, G. and Maggi, F. and Zanero, S.},
	title = {Integrated Detection of Attacks Against Browsers, Web Applications and Databases},
	year = {2009},
	isbn = {9780769539836},
	publisher = {IEEE Computer Society},
	address = {USA},
	url = {https://doi.org/10.1109/EC2ND.2009.13},
	doi = {10.1109/EC2ND.2009.13},
	abstract = {Anomaly-based techniques were exploited successfully to implement protection mechanisms for various systems. Recently, these approaches have been ported to the web domain under the name of "web application anomaly detectors" (or firewalls) with promising results. In particular, those capable of automatically building specifications, or models, of the protected application by observing its traffic (e.g., network packets, system calls, or HTTP requests and responses) are particularly interesting, since they can be deployed with little effort.Typically, the detection accuracy of these systems is significantly influenced by the model building phase (often called training), which clearly depends upon the quality of the observed traffic, which should resemble the normal activity of the protected application and must be also free from attacks. Otherwise, detection may result in significant amounts of false positives (i.e., benign events flagged as anomalous) and negatives (i.e., undetected threats). In this work we describe Masibty, a web application anomaly detector that have some interesting properties. First, it requires the training data not to be attack-free. Secondly, not only it protects the monitored application, it also detects and blocks malicious client-side threats before they are sent to the browser. Third, Masibty intercepts the queries before they are sent to the database, correlates them with the corresponding HTTP requests and blocks those deemed anomalous.Both the accuracy and the performance have been evaluated on real-world web applications with interesting results. The system is almost not influenced by the presence of attacks in the training data and shows only a negligible amount of false positives, although this is paid in terms of a slight performance overhead.},
	booktitle = {Proceedings of the 2009 European Conference on Computer Network Defense},
	pages = {37–45},
	numpages = {9},
	series = {EC2ND '09}
}
