---
---

@article{10.1145/3428256,
	selected = {true},
	abbr = {OOPSLA},
	author = {K\"{o}hler, Mirko and Eskandani, Nafise and Weisenburger, Pascal and Margara, Alessandro and Salvaneschi, Guido},
	title = {Rethinking Safe Consistency in Distributed Object-Oriented Programming},
	year = {2020},
	issue_date = {November 2020},
	publisher = {Association for Computing Machinery},
	address = {New York, NY, USA},
	volume = {4},
	number = {OOPSLA},
	url = {https://doi.org/10.1145/3428256},
	doi = {10.1145/3428256},
	abstract = {Large scale distributed systems require to embrace the trade off between consistency and availability, accepting lower levels of consistency to guarantee higher availability. Existing programming languages are, however, agnostic to this compromise, resulting in consistency guarantees that are the same for the whole application and are implicitly adopted from the middleware or hardcoded in configuration files. In this paper, we propose to integrate availability in the design of an object-oriented language, allowing developers to specify different consistency and isolation constraints in the same application at the granularity of single objects. We investigate how availability levels interact with object structure and define a type system that preserves correct program behavior. Our evaluation shows that our solution performs efficiently and improves the design of distributed applications.},
	journal = {Proc. ACM Program. Lang.},
	month = nov,
	articleno = {188},
	numpages = {30},
	keywords = {consistency, replication, Java, type systems}
}

@article{10.1145/3428207,
	abbr = {OOPSLA},
	author = {Zhang, Yizhou and Salvaneschi, Guido and Myers, Andrew C.},
	title = {Handling Bidirectional Control Flow},
	year = {2020},
	issue_date = {November 2020},
	publisher = {Association for Computing Machinery},
	address = {New York, NY, USA},
	volume = {4},
	number = {OOPSLA},
	url = {https://doi.org/10.1145/3428207},
	doi = {10.1145/3428207},
	abstract = {Pressed by the difficulty of writing asynchronous, event-driven code, mainstream languages have recently been building in support for a variety of advanced control-flow features. Meanwhile, experimental language designs have suggested effect handlers as a unifying solution to programmer-defined control effects, subsuming exceptions, generators, and async–await. However, despite these trends, complex control flow—in particular, control flow that exhibits a bidirectional pattern—remains challenging to manage.  We introduce bidirectional algebraic effects, a new programming abstraction that supports bidirectional control transfer in a more natural way. Handlers of bidirectional effects can raise further effects to transfer control back to the site where the initiating effect was raised, and can use themselves to handle their own effects. We present applications of this expressive power, which falls out naturally as we push toward the unification of effectful programming with object-oriented programming. We pin down the mechanism and the unification formally using a core language that makes generalizations to effect operations and effect handlers.  The usual propagation semantics of control effects such as exceptions conflicts with modular reasoning in the presence of effect polymorphism—it breaks parametricity. Bidirectionality exacerbates the problem. Hence, we set out to show the core language, which builds on the existing tunneling semantics for algebraic effects, is not only type-safe (no effects go unhandled), but also abstraction-safe (no effects are accidentally handled). We devise a step-indexed logical-relations model, and construct its parametricity and soundness proofs. These core results are fully mechanized in Coq. While a full-featured compiler is left to future work, experiments show that as a first-class language feature, bidirectional handlers can be implemented efficiently.},
	journal = {Proc. ACM Program. Lang.},
	month = nov,
	articleno = {139},
	numpages = {30},
	keywords = {type systems, iterators, exceptions, Effect handlers, promises, parametricity}
}

@article{10.1145/3397495,
	abbr = {Comp. Surv.},
	author = {Weisenburger, Pascal and Wirth, Johannes and Salvaneschi, Guido},
	title = {A Survey of Multitier Programming},
	year = {2020},
	issue_date = {September 2020},
	publisher = {Association for Computing Machinery},
	address = {New York, NY, USA},
	volume = {53},
	number = {4},
	issn = {0360-0300},
	url = {https://doi.org/10.1145/3397495},
	doi = {10.1145/3397495},
	abstract = {Multitier programming deals with developing the components that pertain to different tiers in the system (e.g., client and server), mixing them in the same compilation unit. In this paradigm, the code for different tiers is then either generated at run time or it results from the compiler splitting the codebase into components that belong to different tiers based on user annotations, static analysis, types, or a combination of these. In the Web context, multitier languages aim at reducing the distinction between client and server code, by translating the code that is to be executed on the clients to JavaScript or by executing JavaScript on the server, too. Ultimately, the goal of the multitier approach is to improve program comprehension, simplify maintenance and enable formal reasoning about the properties of the whole distributed application.A number of multitier research languages have been proposed over the last decade, which support various degrees of multitier programming and explore different design tradeoffs. In this article, we provide an overview of the existing solutions, discuss their positioning in the design space, and outline open research problems.},
	journal = {ACM Comput. Surv.},
	month = sep,
	articleno = {81},
	numpages = {35},
	keywords = {distributed programming, Multitier languages, tierless languages}
}

@inproceedings{10.1145/3427761.3428346,
	abbr = {FTfJP},
	author = {K\"{o}hler, Mirko and Masoule, Nafise Eskandani and Margara, Alessandro and Salvaneschi, Guido},
	title = {ConSysT: Tunable, Safe Consistency Meets Object-Oriented Programming},
	year = {2020},
	isbn = {9781450381864},
	publisher = {Association for Computing Machinery},
	address = {New York, NY, USA},
	url = {https://doi.org/10.1145/3427761.3428346},
	doi = {10.1145/3427761.3428346},
	abstract = {Data replication is essential in scenarios like geo-distributed datacenters, but poses challenges for data consistency. Developers adopt Strong consistency at the cost of performance or embrace Weak consistency and face a higher programming complexity. We argue that languages should associate consistency to data types. We present , a programming language and middleware that provides abstractions to specify consistency types, enabling mixing different consistency levels in the same application. Such mechanism is fully integrated with object-oriented programming and type system guarantees that different levels can only be mixed correctly.},
	booktitle = {Proceedings of the 22nd ACM SIGPLAN International Workshop on Formal Techniques for Java-Like Programs},
	pages = {15–17},
	numpages = {3},
	keywords = {Java, consistency, replication, type systems},
	location = {Virtual, USA},
	series = {FTfJP 2020}
}

@inproceedings{10.1145/3395363.3397367,
	abbr = {ISSTA},
	author = {Helm, Dominik and K\"{u}bler, Florian and K\"{o}lzer, Jan Thomas and Haller, Philipp and Eichberg, Michael and Salvaneschi, Guido and Mezini, Mira},
	title = {A Programming Model for Semi-Implicit Parallelization of Static Analyses},
	year = {2020},
	isbn = {9781450380089},
	publisher = {Association for Computing Machinery},
	address = {New York, NY, USA},
	url = {https://doi.org/10.1145/3395363.3397367},
	doi = {10.1145/3395363.3397367},
	abstract = {Parallelization of static analyses is necessary to scale to real-world programs, but it is a complex and difficult task and, therefore, often only done manually for selected high-profile analyses. In this paper, we propose a programming model for semi-implicit parallelization of static analyses which is inspired by reactive programming. Reusing the domain-expert knowledge on how to parallelize anal- yses encoded in the programming framework, developers do not need to think about parallelization and concurrency issues on their own. The programming model supports stateful computations, only requires monotonic computations over lattices, and is independent of specific analyses. Our evaluation shows the applicability of the programming model to different analyses and the importance of user-selected scheduling strategies. We implemented an IFDS solver that was able to outperform a state-of-the-art, specialized parallel IFDS solver both in absolute performance and scalability.},
	booktitle = {Proceedings of the 29th ACM SIGSOFT International Symposium on Software Testing and Analysis},
	pages = {428–439},
	numpages = {12},
	keywords = {static analysis, parallelization, concurrency},
	location = {Virtual Event, USA},
	series = {ISSTA 2020}
}
